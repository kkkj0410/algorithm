## 문제 유형

- 유니온 파인드 or 완전 탐색

## 문제 접근

- 답
    - 친구끼리 묶었을 때 팀의 개수
- 주어지는 정보
    - 학생 수 최대 1000 (n)
    - 학생 간의 인간관계 정보 최대 5000 (m)
- 후보
    - 완전탐색
        - 가능
        - 학생의 수가 충분히 작음
        - 완전탐색을 통한 n*n 연산을 시도했을 때, 시간 복잡도를 넘지 않음
    - 유니온 파인드
        - 적합
        - 1번의 친구가 2번이고, 2번의 친구가 3번이라고 하자.
        - 이 경우, 완전 탐색으로 1,2,3번의 친구 리스트를 전부 탐색하는 것도 된다.
        - 하지만 유니온 파인드를 통해, 1, 2, 3번의 최종 친구를 정해놓으면 더 빨리 팀 개수를 구할 수 있다.
- 풀이(유니온 파인드)
    - 목적
        - 팀 개수를 구한다.
    - 단계
        - 자료구조
            - List<Integer>[] FList;
                - 친구 명단을 기록한다.
                - a, b가 친구라면
                    - FList[a].add(b)
                    - FList[b].add(a)
            - List<Integer>[] EList;
                - 원수 명단을 기록한다.
                - 원수의 원수는 친구이므로, 해당 경우는 FList에 등록한다.
            - int[] unionList;
                - 유니온 파인드 연산 결과를 기록한다.
        - 함수
            - makeFriendByE()
                - 원수의 원수를 친구 명단에 기록한다.
            - find(int target)
                - 해당 target의 부모를 return 한다
            - union(int child, int parent)
                - 부모가 없는 child가 parent를 가리키도록 한다.
