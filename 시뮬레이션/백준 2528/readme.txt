### 문제 접근

- 답
    - 최상층에 도달하기 위한 최소 시간
- 주어지는 정보
    - 막대기의 초기 위치, 길이
    - 막대기가 움직일 수 있는 반경
    - 시간에 따른 막대기의 움직임
    
    ⇒ 시간에 따른 전체 막대기의 시작점, 끝점을 알 수 있음
    
- 활용 방안
    - 시간에 따른 전체 막대기의 시작점, 끝점을 알 수 있음
        - USER는 주어진 시간을 통해, 윗층의 막대기를 타고 올라간다.
        - USER가 윗층으로 올라가지 못하면 시간을 추가한다.
- 시간 복잡도
    - log(N*L)
        - N : 최대 층
        - L : 막대기의 이동 반경 / 2
            - ex) 길이 1인 막대기가 2개 있다고 하자. 막대기는 맨 왼쪽/ 오른쪽에 붙어있다.
                - 왼쪽 막대기와 오른쪽 막대기가 만나는 지점은 중간 지점이다.
                - 따라서 두 막대기가 만나기 위한 최대 횟수는 L

### 풀이법)

- class bar
    - int dis
        - 해당 층의 막대기 길이
    - int d
        - 해당 막대기의 초기 방향
    
- public static boolean TN(bar a, bar b, int cnt, int MAX_L)
    - 막대기 a, 막대기 b가 겹치면 true
    - 시간에 따른 막대기의 시작점, 끝점 구하기
        1. 막대기의 왕복 횟수 제거
            - int a_move = cnt % (a_remain*2);
                - = 현재 시간 % (0초일때 막대기의 남은 여백 * 2)
        2. 막대기가 벽에 부딪히는 경우에는?
            - a_move = a_move % a_remain;
                - 막대기를 반대편 벽에 붙이고 난 후의 남은 횟수
            - a_move횟수를 막대기에 적용(반대 방향임을 고려해서 적용)
        3. 막대기가 벽에 부딪히지 않으면?
            - a_move횟수를 막대기에 적용
    - 막대기들의 시작점, 끝점을 비교해서 마지막 층까지 가기 위한 시간을 구함
