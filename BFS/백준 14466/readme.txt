## 문제 유형

- 완전 탐색 + BFS

## 문제 접근

- 답
    - 길을 건너야만 만날 수 있는 소의 쌍 수
- 주어지는 정보
    - 맵 크기 최대 10000 (N*N)
    - 소 개수 최대 100 (K)
- 후보
    - 완전탐색
        - 가능
        - N, K가 충분히 작으므로 시간 초과는 없을 것으로 예상
        
        ⇒ BFS를 통해 완전탐색 시행
        
- 풀이
    - 목적
        - BFS 탐색으로 다리를 건너야만 만날 수 있는 소를 카운팅한다.
    - 단계
        - 자료구조
            - Cow[i] cowList;
                - i번째로 입력된 소의 좌표를 등록한다.
            - int[y][x] map;
                - (y,x) 좌표의 소의 i 번호를 적는다.
            - boolean[][][][] bridge;
                - (y,x) → (y’,x’) 좌표로 이어지는 다리를 true로 등록
                - Q) 배열이 커서 시간 초과가 일어나지 않나?
                    - 일어나지 않는다
                    - 100^4 byte = 100MB
        - 함수
            - bfs()
                - 소를 순서대로 뽑아서 Map 전체를 탐색한다
                - 단계
                    - 1~K 순서대로 소를 1마리 뽑는다
                    - 해당 소에대한 BFS 탐색을 진행한다
                    - 탐색 시, 다리가 있는 곳은 지나가지 않는다.
            - findCow(int num, boolean[][] visited)
                - BFS()탐색에서 방문하지 못한 소를 카운팅한다.
                - 단계
                    - BFS 탐색을 시작한 소의 번호(num)
                    - BFS 탐색 방문 기록(visited)
                    - 위 2개를 받는다.
                    - visited를 확인하여, 방문하지 못한 소가 있다면 카운팅한다.
                    - 1~num의 소는 카운팅에서 제외한다.(이미 이전 소에 대한 bfs()탐색으로 카운팅이 돼있으므로)
                    - 카운팅 값은 결과값에 더한다.
